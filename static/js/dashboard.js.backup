/**
 * CryptoNinja ü•∑ - Stealth Trading AI
 * Sistema Paper Trading com Fluxo Simples:
 * 1. Gerar Sinal ‚Üí 2. Aprovar/Rejeitar ‚Üí 3. Contabilizar P&L ‚Üí 4. Calcular Win Rate
 */

class SimpleTradingDashboard {    constructor() {
        this.socket = null;
        this.currentSignal = null;
        this.currentSymbol = 'BTCUSDT';
        this.currentTimeframe = '5m';
        this.tradingViewWidget = null;
        this.isConnected = false;
        this.lastPrices = {};
        this.priceUpdateInterval = null;
        this.multiSymbolPriceInterval = null;
        this.activeTradeSymbols = [];
        this.notifications = [];
        this.portfolio = {
            total_trades: 0,
            win_rate: 0,
            total_pnl: 0,
            active_trades: 0
        };
          // Assets suportados - apenas crypto ap√≥s remo√ß√£o do forex
        this.supportedAssets = {
            'crypto': ['BTCUSDT', 'ETHUSDT', 'ADAUSDT', 'DOTUSDT', 'LINKUSDT', 'BNBUSDT', 'XRPUSDT', 'SOLUSDT', 'AVAXUSDT', 'MATICUSDT', 'UNIUSDT', 'ATOMUSDT', 'ALGOUSDT', 'LTCUSDT']
        };
        
        this.init();
    }

    // Fun√ß√£o global para formata√ß√£o de pre√ßos com casas decimais din√¢micas
    formatPrice(price, symbol) {
        const getDecimalPlaces = (symbol, price) => {
            const lowPriceAssets = ['ADAUSDT', 'XRPUSDT', 'DOGEUSDT', 'SHIBUSDT', 'TRXUSDT'];
            const midPriceAssets = ['LINKUSDT', 'UNIUSDT', 'AAVEUSDT', 'COMPUSDT'];
            
            if (lowPriceAssets.includes(symbol)) {
                return { min: 4, max: 6 };
            } else if (midPriceAssets.includes(symbol)) {
                return { min: 3, max: 4 };
            } else if (price < 1) {
                return { min: 4, max: 6 };
            } else if (price < 10) {
                return { min: 3, max: 4 };
            } else if (price < 100) {
                return { min: 2, max: 3 };
            } else {
                return { min: 2, max: 2 };
            }
        };
        
        const decimals = getDecimalPlaces(symbol, price);
        return price.toLocaleString('en-US', {
            minimumFractionDigits: decimals.min,
            maximumFractionDigits: decimals.max
        });
    }    init() {
        // Sincronizar timeframe com o valor selecionado no HTML
        const timeframeSelector = document.getElementById('timeframeSelector');
        if (timeframeSelector && timeframeSelector.value) {
            this.currentTimeframe = timeframeSelector.value;
        }
          // Sincronizar ativo com o valor selecionado no HTML
        const assetSelector = document.getElementById('assetSelector');
        if (assetSelector && assetSelector.value) {
            this.currentSymbol = assetSelector.value;
        }
          // Atualizar elementos da interface com o ativo inicial
        this.updateInterfaceElements();
        
        // Inicializar contador de trades ativos
        this.updateActiveTradesCounter(0);
        
        this.initTradingView();
        this.initEventListeners();
        this.initWebSocket();
        this.loadPortfolio();
        this.loadActiveTradesStatus();
        this.loadTradesHistory();
        
        // Carregar dados de mercado inicial
        this.updateCurrentPrice();
          // Auto-refresh a cada 30 segundos
        setInterval(() => {
            this.loadPortfolio();
            this.loadActiveTradesStatus();
            this.updateCurrentPrice();
        }, 30000);
        
        // Atualizar pre√ßo a cada 10 segundos
        setInterval(() => {
            this.updateCurrentPrice();
        }, 10000);
        
        // Expandir dados ap√≥s startup (executar ap√≥s 30 segundos)
        this.expandDataAfterStartup();
        
        console.log('‚úÖ CryptoNinja ü•∑ inicializado! Pronto para trades furtivos...');
    }

    initTradingView() {
        console.log('üìà Inicializando TradingView...');
        this.tradingViewWidget = new TradingView.widget({
            "width": "100%",
            "height": "500",
            "symbol": "BINANCE:BTCUSDT",
            "interval": "5",
            "timezone": "America/Sao_Paulo",
            "theme": "light",
            "style": "1",
            "locale": "pt_BR",
            "toolbar_bg": "#f1f3f6",
            "enable_publishing": false,
            "hide_top_toolbar": false,
            "hide_legend": true,
            "save_image": false,
            "container_id": "tradingview_chart",
            "studies": [
                "RSI@tv-basicstudies",
                "MASimple@tv-basicstudies",
                "MACD@tv-basicstudies"
            ]
        });
    }

    initEventListeners() {
        console.log('üéØ Configurando event listeners...');
        
        // Remover event listeners existentes para evitar duplica√ß√£o
        const generateBtn = document.getElementById('generateSignalBtn');
        const confirmBtn = document.getElementById('confirmSignalBtn');
        const rejectBtn = document.getElementById('rejectSignalBtn');
        
        // Clonar elementos para remover todos os event listeners
        const newGenerateBtn = generateBtn.cloneNode(true);
        const newConfirmBtn = confirmBtn.cloneNode(true);
        const newRejectBtn = rejectBtn.cloneNode(true);
        
        generateBtn.parentNode.replaceChild(newGenerateBtn, generateBtn);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        rejectBtn.parentNode.replaceChild(newRejectBtn, rejectBtn);
        
        // Gerar sinal
        newGenerateBtn.addEventListener('click', () => {
            this.generateSignal();
        });

        // Confirmar sinal
        newConfirmBtn.addEventListener('click', () => {
            this.confirmSignal();
        });

        // Rejeitar sinal
        newRejectBtn.addEventListener('click', () => {
            this.rejectSignal();
        });

        // Atualizar hist√≥rico
        document.getElementById('refreshHistoryBtn').addEventListener('click', () => {
            this.loadTradesHistory();
        });

        // Seletor de ativos
        document.getElementById('assetSelector').addEventListener('change', (e) => {
            this.changeAsset(e.target.value);
        });

        // Seletor de timeframe
        document.getElementById('timeframeSelector').addEventListener('change', (e) => {
            console.log(`üîÑ Timeframe selecionado: ${e.target.value}`);
            this.changeTimeframe(e.target.value);
        });        // Iniciar atualiza√ß√£o autom√°tica de pre√ßos
        this.startPriceUpdates();
          // Otimizar atualiza√ß√£o baseada na visibilidade da p√°gina
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // P√°gina n√£o vis√≠vel - reduzir frequ√™ncia
                this.stopPriceUpdates();
                this.priceUpdateInterval = setInterval(() => {
                    this.updateCurrentPrice();
                }, 5000); // 5 segundos quando n√£o vis√≠vel
                
                // Manter monitoramento multi-s√≠mbolos com frequ√™ncia reduzida
                if (this.activeTradeSymbols && this.activeTradeSymbols.length > 0) {
                    this.multiSymbolPriceInterval = setInterval(() => {
                        this.activeTradeSymbols.forEach(symbol => {
                            this.updatePriceForSymbol(symbol);
                        });
                    }, 10000); // 10 segundos quando n√£o vis√≠vel
                }
            } else {
                // P√°gina vis√≠vel - m√°xima frequ√™ncia
                this.startPriceUpdates();
                
                // Recarregar trades ativos para reiniciar monitoramento multi-s√≠mbolos
                this.loadActiveTradesStatus();
            }
        });
    }
    
    startPriceUpdates() {
        // Limpar intervalo anterior se existir
        if (this.priceUpdateInterval) {
            clearInterval(this.priceUpdateInterval);
        }
        
        // Atualizar pre√ßo imediatamente
        this.updateCurrentPrice();
        
        // Configurar atualiza√ß√£o autom√°tica a cada 1 segundo para sincronizar com o gr√°fico
        this.priceUpdateInterval = setInterval(() => {
            this.updateCurrentPrice();
        }, 1000);
        
        console.log('üîÑ Atualiza√ß√£o autom√°tica de pre√ßos iniciada (1s)');
    }
      stopPriceUpdates() {
        if (this.priceUpdateInterval) {
            clearInterval(this.priceUpdateInterval);
            this.priceUpdateInterval = null;
            console.log('‚èπÔ∏è Atualiza√ß√£o autom√°tica de pre√ßos parada');
        }
        
        // Parar tamb√©m o intervalo de captura do gr√°fico
        if (this.chartPriceInterval) {
            clearInterval(this.chartPriceInterval);
            this.chartPriceInterval = null;
            console.log('‚èπÔ∏è Captura de pre√ßos do gr√°fico interrompida');
        }
        
        // Parar monitoramento multi-s√≠mbolos
        this.stopMultiSymbolPriceMonitoring();
    }

    initWebSocket() {
        console.log('üîó Conectando WebSocket...');
        this.socket = io();
        
        this.socket.on('connect', () => {
            console.log('‚úÖ WebSocket conectado');
            this.isConnected = true;
            this.updateBotStatus(true);
            this.showNotification('Conectado ao servidor em tempo real', 'success');
        });

        this.socket.on('disconnect', () => {
            console.log('‚ùå WebSocket desconectado');
            this.isConnected = false;
            this.updateBotStatus(false);
            this.showNotification('Conex√£o perdida - tentando reconectar...', 'warning');
        });

        this.socket.on('price_update', (data) => {
            this.handlePriceUpdate(data);
        });

        this.socket.on('trade_update', (data) => {
            this.handleTradeUpdate(data);
        });

        // Novos eventos para notifica√ß√µes em tempo real
        this.socket.on('new_signal', (data) => {
            this.handleNewSignal(data);
        });

        this.socket.on('trade_opened', (data) => {
            this.handleTradeOpened(data);
        });

        this.socket.on('trade_closed', (data) => {
            this.handleTradeClosed(data);
        });

        this.socket.on('portfolio_update', (data) => {
            this.handlePortfolioUpdate(data);
        });
    }

    updateBotStatus(isRunning) {
        const statusElement = document.getElementById('botStatus');
        const statusTextElement = document.getElementById('botStatusText');
        
        if (isRunning) {
            statusElement.className = 'status-indicator status-running';
            statusTextElement.textContent = 'Online';
        } else {
            statusElement.className = 'status-indicator status-stopped';
            statusTextElement.textContent = 'Offline';
        }
    }

    async generateSignal() {
        console.log('üé∞ Gerando novo sinal...');
        const btn = document.getElementById('generateSignalBtn');
        const originalText = btn.innerHTML;
        
        try {
            btn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Gerando...';
            btn.disabled = true;

            const response = await fetch('/api/generate_signal', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    symbol: this.currentSymbol,
                    timeframe: this.currentTimeframe
                })
            });

            const data = await response.json();
              if (data.success && data.signal) {
                console.log('‚úÖ Sinal gerado:', data.signal);
                this.currentSignal = data.signal;
                this.displayCurrentSignal(data.signal);
                // Removido: notifica√ß√£o duplicada - ser√° exibida via WebSocket
            } else {
                console.error('‚ùå Erro ao gerar sinal:', data.error);
                this.showSpecificErrorAlert(data.error, data.error_type);
            }
        } catch (error) {
            console.error('‚ùå Erro de conex√£o ao gerar sinal:', error);
            this.showAlert('Erro de conex√£o ao gerar sinal. Verifique sua internet.', 'danger');
        } finally {
            btn.innerHTML = originalText;
            btn.disabled = false;
        }
    }

    displayCurrentSignal(signal) {
        console.log('üìä Exibindo sinal:', signal);
        const card = document.getElementById('currentSignalCard');
        const actionElement = document.getElementById('signalAction');
        const priceElement = document.getElementById('signalPrice');
        const symbolElement = document.getElementById('signalSymbol');
        const confidenceElement = document.getElementById('signalConfidence');
        const stopLossElement = document.getElementById('signalStopLoss');
        const takeProfitElement = document.getElementById('signalTakeProfit');

        // Definir cor da a√ß√£o
        actionElement.className = `badge fs-6 ${signal.signal_type === 'buy' ? 'bg-success' : 'bg-danger'}`;
        actionElement.textContent = signal.signal_type?.toUpperCase() || 'N/A';
        
        const price = parseFloat(signal.entry_price);
        priceElement.textContent = `$${this.formatPrice(price, signal.symbol)}`;
        symbolElement.textContent = signal.symbol;
        
        // Exibir confian√ßa como porcentagem
        const confidence = (signal.confidence * 100).toFixed(1);
        confidenceElement.textContent = `${confidence}%`;
        
        // Exibir stop loss e take profit
        if (signal.stop_loss) {
                    const slPrice = parseFloat(signal.stop_loss);
                    stopLossElement.textContent = `$${this.formatPrice(slPrice, signal.symbol)}`;
                } else {
                    stopLossElement.textContent = 'N/A';
                }
                
                if (signal.take_profit) {
                    const tpPrice = parseFloat(signal.take_profit);
                    takeProfitElement.textContent = `$${this.formatPrice(tpPrice, signal.symbol)}`;
                } else {
                    takeProfitElement.textContent = 'N/A';
                }

        // Aplicar classe CSS baseada na a√ß√£o
        card.className = `card signal-card signal-alert mb-4 ${signal.signal_type?.toLowerCase() || 'neutral'}`;
        card.style.display = 'block';
    }

    async confirmSignal() {
        if (!this.currentSignal) {
            this.showAlert('Nenhum sinal para confirmar', 'warning');
            return;
        }

        console.log('‚úÖ Confirmando sinal:', this.currentSignal);

        try {
            const response = await fetch('/api/paper_trading/confirm_signal', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    signal: this.currentSignal,
                    amount: 1000 // Valor padr√£o fict√≠cio
                })
            });

            const data = await response.json();
            
            if (data.success) {
                console.log('‚úÖ Trade confirmado com sucesso!');
                this.showAlert('‚úÖ Trade confirmado com sucesso!', 'success');
                this.hideCurrentSignal();
                this.loadPortfolio();
                this.loadActiveTradesStatus();
                this.loadTradesHistory();
            } else {
                console.error('‚ùå Erro ao confirmar trade:', data.error);
                this.showAlert('Erro ao confirmar trade: ' + (data.error || 'Erro desconhecido'), 'danger');
            }
        } catch (error) {
            console.error('‚ùå Erro de conex√£o ao confirmar trade:', error);
            this.showAlert('Erro de conex√£o ao confirmar trade', 'danger');
        }
    }

    rejectSignal() {
        console.log('‚ùå Sinal rejeitado pelo usu√°rio');
        this.showAlert('Sinal rejeitado', 'info');
        this.hideCurrentSignal();
    }

    hideCurrentSignal() {
        const card = document.getElementById('currentSignalCard');
        card.style.display = 'none';
        this.currentSignal = null;
    }

    async loadPortfolio() {
        try {
            const response = await fetch('/api/paper_trading/portfolio');
            const data = await response.json();
            
            if (data.success) {
                this.portfolio = data.portfolio;
                this.updateStatsDisplay();
                console.log('üìä Portfolio atualizado:', this.portfolio);
            }
        } catch (error) {
            console.error('‚ùå Erro ao carregar portfolio:', error);
        }
    }

    updateStatsDisplay() {
        document.getElementById('totalTrades').textContent = this.portfolio.total_trades;
        
        const winRateElement = document.getElementById('winRate');
        const winRate = this.portfolio.win_rate;
        winRateElement.textContent = `${winRate.toFixed(1)}%`;
        
        // Aplicar cores baseadas na taxa de acerto
        winRateElement.className = '';
        if (winRate >= 60) {
            winRateElement.classList.add('win-rate-good');
        } else if (winRate >= 40) {
            winRateElement.classList.add('win-rate-neutral');
        } else {
            winRateElement.classList.add('win-rate-bad');
        }
        
        const pnlElement = document.getElementById('totalPnL');
        const pnl = this.portfolio.total_pnl;
        pnlElement.textContent = `R$ ${pnl.toFixed(2)}`;
        pnlElement.className = pnl >= 0 ? 'text-success fw-bold' : 'text-danger fw-bold';
        
        document.getElementById('activeTrades').textContent = this.portfolio.active_trades;
    }    async loadActiveTradesStatus() {
        try {
            const response = await fetch('/api/paper_trading/portfolio');
            const data = await response.json();
            
            if (data.success && data.active_trades) {
                this.displayActiveTrades(data.active_trades);
                
                // Iniciar monitoramento de pre√ßos para todos os s√≠mbolos ativos
                this.startMultiSymbolPriceMonitoring(data.active_trades);
            }
        } catch (error) {
            console.error('‚ùå Erro ao carregar trades ativos:', error);
        }
    }

    startMultiSymbolPriceMonitoring(activeTrades) {
        // Extrair s√≠mbolos √∫nicos dos trades ativos
        const activeSymbols = [...new Set(activeTrades.map(trade => trade.symbol))];
        
        console.log(`üîç Iniciando monitoramento multi-s√≠mbolos: ${activeSymbols.join(', ')}`);
        
        // Armazenar s√≠mbolos ativos para refer√™ncia
        this.activeTradeSymbols = activeSymbols;
        
        // Atualizar pre√ßos de todos os s√≠mbolos ativos imediatamente
        activeSymbols.forEach(symbol => {
            if (symbol !== this.currentSymbol) {
                this.updatePriceForSymbol(symbol);
            }
        });
        
        // Configurar intervalo para atualiza√ß√£o cont√≠nua de todos os s√≠mbolos
        if (this.multiSymbolPriceInterval) {
            clearInterval(this.multiSymbolPriceInterval);
        }
        
        if (activeSymbols.length > 0) {
            this.multiSymbolPriceInterval = setInterval(() => {
                activeSymbols.forEach(symbol => {
                    this.updatePriceForSymbol(symbol);
                });
            }, 5000); // Atualizar a cada 5 segundos
            
            console.log(`‚è∞ Monitoramento autom√°tico configurado para ${activeSymbols.length} s√≠mbolos`);
        }
    }

    async updatePriceForSymbol(symbol) {
        try {
            // Usar endpoint de tempo real primeiro
            let response = await fetch(`/api/price/realtime/${symbol}`);
            let data = await response.json();
            
            // Se o endpoint tempo real falhou, usar o tradicional
            if (!data.success) {
                response = await fetch(`/api/price/${symbol}`);
                data = await response.json();
            }
            
            if (data.success) {
                // Simular evento de atualiza√ß√£o de pre√ßo via WebSocket
                this.handlePriceUpdate({
                    symbol: symbol,
                    price: data.price,
                    source: 'api_poll'
                });
            }
        } catch (error) {
            console.warn(`‚ö†Ô∏è Erro ao atualizar pre√ßo para ${symbol}:`, error);
        }
    }

    stopMultiSymbolPriceMonitoring() {
        if (this.multiSymbolPriceInterval) {
            clearInterval(this.multiSymbolPriceInterval);
            this.multiSymbolPriceInterval = null;
            console.log('‚èπÔ∏è Monitoramento multi-s√≠mbolos interrompido');
        }
    }    displayActiveTrades(activeTrades) {
        const container = document.getElementById('activeTradesList');
        
        // Atualizar contador
        this.updateActiveTradesCounter(activeTrades.length);
        
        if (activeTrades.length === 0) {
            container.innerHTML = `
                <div class="text-center py-4">
                    <i class="fas fa-chart-line fa-3x text-muted mb-3"></i>
                    <p class="text-muted mb-0">Nenhum trade ativo no momento</p>
                    <small class="text-muted">Gere um sinal para come√ßar a negociar</small>
                </div>
            `;
            return;
        }
        
        container.innerHTML = activeTrades.map(trade => {
            const currentPrice = parseFloat(trade.current_price || trade.entry_price);
            const entryPrice = parseFloat(trade.entry_price);
            const pnlPercent = ((currentPrice - entryPrice) / entryPrice * 100).toFixed(2);
        const pnlValue = this.formatPrice(currentPrice - entryPrice, this.currentSymbol);
            const isProfit = currentPrice >= entryPrice;
              return `
                <div class="card mb-3 shadow-sm border-0 trade-card">
                    <div class="card-body p-3">
                        <!-- Header com s√≠mbolo e tipo -->
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <div class="d-flex align-items-center">
                                <h6 class="mb-0 fw-bold trade-symbol">${trade.symbol}</h6>
                                <span class="badge ${trade.trade_type === 'BUY' ? 'bg-success' : 'bg-danger'} ms-2">
                                    <i class="fas ${trade.trade_type === 'BUY' ? 'fa-arrow-up' : 'fa-arrow-down'}"></i> ${trade.trade_type}
                                </span>
                            </div>
                            <button class="btn btn-outline-danger btn-sm" onclick="dashboard.closeTrade('${trade.id}')" title="Fechar Trade">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                        
                        <!-- Pre√ßos principais -->
                        <div class="row g-2 mb-3">
                            <div class="col-6">
                                <div class="bg-light rounded p-2 text-center">
                                    <small class="text-muted d-block mb-1">Pre√ßo de Entrada</small>
                                    <strong class="text-dark">$${this.formatPrice(entryPrice, trade.symbol)}</strong>
                                </div>
                            </div>
                            <div class="col-6">
                                <div class="bg-light rounded p-2 text-center">
                                    <small class="text-muted d-block mb-1">Pre√ßo Atual</small>
                                    <strong class="${isProfit ? 'text-success' : 'text-danger'}">$${this.formatPrice(currentPrice, trade.symbol)}</strong>
                                </div>
                            </div>
                        </div>
                          <!-- P&L -->
                        <div class="text-center mb-3">
                            <div class="${isProfit ? 'bg-success' : 'bg-danger'} bg-opacity-10 rounded p-2">
                                <small class="text-muted d-block mb-1">Resultado Atual</small>
                                <div class="trade-pnl ${isProfit ? 'profit' : 'loss'}">
                                    ${isProfit ? '+' : ''}$${pnlValue} (${isProfit ? '+' : ''}${pnlPercent}%)
                                </div>
                            </div>
                        </div>
                        
                        <!-- Stop Loss e Take Profit -->
                        <div class="row g-2 mb-3">
                            <div class="col-6">
                                <div class="border border-danger border-opacity-25 rounded p-2 text-center">
                                    <small class="text-muted d-block mb-1">Stop Loss</small>
                                    <span class="text-danger fw-bold">
                                        ${trade.stop_loss ? '$' + this.formatPrice(parseFloat(trade.stop_loss), trade.symbol) : 'N/A'}
                                    </span>
                                </div>
                            </div>
                            <div class="col-6">
                                <div class="border border-success border-opacity-25 rounded p-2 text-center">
                                    <small class="text-muted d-block mb-1">Take Profit</small>
                                    <span class="text-success fw-bold">
                                        ${trade.take_profit ? '$' + this.formatPrice(parseFloat(trade.take_profit), trade.symbol) : 'N/A'}
                                    </span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Confian√ßa -->
                        <div class="text-center">
                            <small class="text-muted d-block mb-1">Confian√ßa do Sinal</small>
                            <span class="badge bg-info fs-6">
                                ${trade.signal_confidence ? (trade.signal_confidence * 100).toFixed(1) + '%' : 'N/A'}
                            </span>
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    }    async closeTrade(tradeId) {
        console.log('üîí Fechando trade:', tradeId);
        
        if (!confirm('Tem certeza que deseja fechar este trade?')) {
            return;
        }
        
        try {
            const response = await fetch('/api/paper_trading/close_trade', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    trade_id: tradeId
                })
            });

            const data = await response.json();
            
            if (data.success) {
                console.log('‚úÖ Trade fechado com sucesso!');
                this.showAlert('Trade fechado com sucesso!', 'success');
                
                // For√ßar atualiza√ß√£o imediata de todas as se√ß√µes
                setTimeout(() => {
                    this.loadPortfolio();
                    this.loadActiveTradesStatus();
                    this.loadTradesHistory();
                    console.log('üìä Interface atualizada ap√≥s fechamento manual');
                }, 300);
                
            } else {
                console.error('‚ùå Erro ao fechar trade:', data.error);
                this.showAlert('Erro ao fechar trade: ' + (data.error || 'Erro desconhecido'), 'danger');
            }
        } catch (error) {
            console.error('‚ùå Erro de conex√£o ao fechar trade:', error);
            this.showAlert('Erro de conex√£o ao fechar trade. Verifique sua internet.', 'danger');
        }
    }

    async loadTradesHistory() {
        console.log('üìú Carregando hist√≥rico de trades...');
        
        try {
            const response = await fetch('/api/paper_trading/history');
            const data = await response.json();
            
            if (data.success) {
                this.displayTradesHistory(data.trades);
                console.log(`üìä Hist√≥rico carregado: ${data.trades.length} trades`);
            }
        } catch (error) {
            console.error('‚ùå Erro ao carregar hist√≥rico:', error);
        }
    }

    displayTradesHistory(trades) {
        const tbody = document.querySelector('#tradesHistoryTable tbody');
        
        if (trades.length === 0) {
            tbody.innerHTML = '<tr><td colspan="11" class="text-center text-muted py-4">Nenhum trade realizado ainda</td></tr>';
            return;
        }
        
        tbody.innerHTML = trades.slice(0, 20).map(trade => `
            <tr>
                <td><strong>${trade.symbol}</strong></td>
                <td><span class="badge ${trade.trade_type === 'BUY' ? 'bg-success' : 'bg-danger'}">${trade.trade_type}</span></td>
                <td>$${this.formatPrice(parseFloat(trade.entry_price), trade.symbol)}</td>
                <td><span class="text-danger">${trade.stop_loss ? ((Math.abs(trade.stop_loss - trade.entry_price) / trade.entry_price) * 100).toFixed(1) + '%' : 'N/A'}</span></td>
                <td><span class="text-success">${trade.take_profit ? ((Math.abs(trade.take_profit - trade.entry_price) / trade.entry_price) * 100).toFixed(1) + '%' : 'N/A'}</span></td>
                <td>${trade.exit_price ? '$' + this.formatPrice(parseFloat(trade.exit_price), trade.symbol) : '-'}</td>
                <td>
                    <span class="fw-bold ${trade.pnl >= 0 ? 'text-success' : 'text-danger'}">
                        ${trade.pnl >= 0 ? 'GANHO' : 'PERDA'} (${trade.pnl_percent ? trade.pnl_percent.toFixed(2) + '%' : '0%'})
                    </span>
                </td>
                <td>
                    <span class="badge bg-info">
                        ${trade.signal_confidence ? (trade.signal_confidence * 100).toFixed(1) + '%' : 'N/A'}
                    </span>
                </td>
                <td>
                    <span class="badge ${trade.exit_reason === 'profit' ? 'bg-success' : trade.exit_reason === 'loss' ? 'bg-danger' : 'bg-secondary'}">
                        ${trade.exit_reason ? (trade.exit_reason === 'profit' ? 'Take Profit' : trade.exit_reason === 'loss' ? 'Stop Loss' : trade.exit_reason === 'manual' ? 'Manual' : trade.exit_reason) : '-'}
                    </span>
                </td>
                <td><small>${new Date(trade.timestamp).toLocaleString('pt-BR')}</small></td>
                <td>
                    <span class="badge ${trade.status === 'open' ? 'bg-warning' : trade.pnl >= 0 ? 'bg-success' : 'bg-danger'}">
                        ${trade.status === 'open' ? 'Aberto' : (trade.pnl >= 0 ? 'Lucro' : 'Perda')}
                    </span>
                </td>
            </tr>
        `).join('');
    }    handlePriceUpdate(data) {
        // Atualizar pre√ßos em tempo real
        console.log('üí∞ Atualiza√ß√£o de pre√ßo:', data);
        
        // Sempre armazenar o pre√ßo atualizado
        this.lastPrices[data.symbol] = data.price;
        
        // Atualizar display se for o ativo atualmente selecionado no gr√°fico
        if (data.symbol === this.currentSymbol) {
            this.displayCurrentPrice(data.price);
        }
        
        // SEMPRE atualizar trades ativos, independentemente do s√≠mbolo selecionado
        // Isso permite que trades de diferentes ativos sejam atualizados em tempo real
        this.updateActiveTradesPricesForSymbol(data.symbol, data.price);
    }

    handleTradeUpdate(data) {
        // Atualizar trades em tempo real
        console.log('üìà Atualiza√ß√£o de trade:', data);
        this.loadPortfolio();
        this.loadActiveTradesStatus();
        
        // Mostrar notifica√ß√£o de atualiza√ß√£o
        if (data.type === 'stop_loss_hit') {
            this.showNotification(`üõë Stop Loss atingido para ${data.symbol}`, 'warning');
        } else if (data.type === 'take_profit_hit') {
            this.showNotification(`üéØ Take Profit atingido para ${data.symbol}`, 'success');
        }
    }    // Novas fun√ß√µes para notifica√ß√µes em tempo real
    handleNewSignal(data) {
        console.log('üéØ Novo sinal recebido:', data);
        
        // S√≥ mostrar notifica√ß√£o se for para o ativo atual
        if (data.symbol === this.currentSymbol) {
            const confidence = (data.confidence * 100).toFixed(1);
            const signalType = data.signal_type.toUpperCase();
            
            this.showNotification(
                `üéØ NOVO SINAL: ${signalType} ${data.symbol} | Confian√ßa: ${confidence}% | Pre√ßo: $${data.entry_price}`,
                'info',
                true // Dura√ß√£o extendida
            );
            
            // Auto-refresh do portfolio
            setTimeout(() => {
                this.loadPortfolio();
            }, 1000);
        } else {
            console.log(`üìä Sinal recebido para ${data.symbol}, mas ativo atual √© ${this.currentSymbol} - notifica√ß√£o suprimida`);
        }
    }handleTradeOpened(data) {
        console.log('üìä Trade aberto:', data);
        
        this.showNotification(
            `üìä Trade ${data.trade_type} aberto para ${data.symbol} por $${data.entry_price}`,
            'success'
        );
        
        this.loadPortfolio();
        this.loadActiveTradesStatus(); // Isso reiniciar√° o monitoramento multi-s√≠mbolos
    }    handleTradeClosed(data) {
        console.log('üîí Trade fechado:', data);
        
        const pnlText = data.pnl >= 0 ? `+$${this.formatPrice(data.pnl, this.currentSymbol)}` : `-$${this.formatPrice(Math.abs(data.pnl), this.currentSymbol)}`;
        const icon = data.pnl >= 0 ? 'üí∞' : 'üìâ';
        const type = data.pnl >= 0 ? 'success' : 'danger';
        
        // Mensagem mais detalhada da notifica√ß√£o
        const reasonText = data.exit_reason === 'take_profit' ? 'Take Profit' : 
                          data.exit_reason === 'stop_loss' ? 'Stop Loss' :
                          data.exit_reason === 'manual' ? 'Manual' : 'Fechado';
        
        this.showNotification(
            `${icon} Trade ${data.symbol} fechado: ${pnlText} (${reasonText})`,
            type
        );
        
        // For√ßar atualiza√ß√£o completa da interface
        setTimeout(() => {
            this.loadPortfolio();
            this.loadActiveTradesStatus(); // Isso reiniciar√° o monitoramento multi-s√≠mbolos com a lista atualizada
            this.loadTradesHistory(); // Atualizar hist√≥rico imediatamente
            console.log('üìä Interface atualizada ap√≥s fechamento de trade');
        }, 500); // Aguardar 500ms para garantir que o servidor processou
    }

    handlePortfolioUpdate(data) {
        console.log('üíº Portfolio atualizado:', data);
        
        // Atualizar dados do portfolio sem fazer nova requisi√ß√£o
        this.portfolio = data.portfolio;
        this.updateStatsDisplay();
        
        // Mostrar notifica√ß√£o se houve mudan√ßa significativa
        if (data.significant_change) {
            const pnlChange = data.pnl_change || 0;
            if (Math.abs(pnlChange) > 10) { // Apenas para mudan√ßas > $10
                const icon = pnlChange >= 0 ? 'üìà' : 'üìâ';
                const type = pnlChange >= 0 ? 'success' : 'danger';
                this.showNotification(
                    `${icon} P&L atualizado: ${pnlChange >= 0 ? '+' : ''}$${this.formatPrice(Math.abs(pnlChange), this.currentSymbol)}`,
                    type
                );
            }
        }
    }    updateActiveTradesPrices(newPrice) {
        // Atualizar pre√ßos dos trades ativos na interface
        const activeTradesContainer = document.getElementById('activeTradesList');
        if (activeTradesContainer) {
            // Esta fun√ß√£o ser√° chamada para atualizar pre√ßos em tempo real
            // sem recarregar toda a lista
            this.loadActiveTradesStatus();
        }
    }

    updateActiveTradesPricesForSymbol(symbol, newPrice) {
        // Atualizar pre√ßos de trades ativos para um s√≠mbolo espec√≠fico
        console.log(`üí∞ Atualizando pre√ßos para ${symbol}: $${this.formatPrice(newPrice, symbol)}`);
        
        const activeTradesContainer = document.getElementById('activeTradesList');
        if (!activeTradesContainer) return;
        
        // Buscar cards de trades do s√≠mbolo espec√≠fico
        const tradeCards = activeTradesContainer.querySelectorAll('.trade-card');
        
        tradeCards.forEach(card => {
            const symbolElement = card.querySelector('.text-primary');
            if (symbolElement && symbolElement.textContent.trim() === symbol) {
                // Encontrar e atualizar elementos de pre√ßo atual
                const currentPriceElements = card.querySelectorAll('strong');
                
                currentPriceElements.forEach(element => {
                    if (element.parentElement && 
                        element.parentElement.textContent.includes('Pre√ßo Atual')) {
                        // Atualizar pre√ßo atual
                        const oldPrice = parseFloat(element.textContent.replace(/[$,]/g, ''));
                        element.textContent = `$${this.formatPrice(newPrice, symbol)}`;
                        
                        // Anima√ß√£o visual baseada na dire√ß√£o
                        const isUpward = newPrice > oldPrice;
                        element.classList.remove('text-success', 'text-danger');
                        element.classList.add(isUpward ? 'text-success' : 'text-danger');
                        
                        // Efeito de destaque
                        element.style.animation = isUpward ? 'priceFlash 0.6s ease-in-out' : 'priceFlashRed 0.6s ease-in-out';
                        setTimeout(() => {
                            element.style.animation = '';
                        }, 600);
                    }
                });
                
                // Atualizar P&L do trade automaticamente
                this.updateTradeCardPnL(card, symbol, newPrice);
            }
        });
        
        // Executar anima√ß√£o visual geral
        this.updateActiveTradesPricesVisual(newPrice);
    }

    updateTradeCardPnL(card, symbol, currentPrice) {
        // Atualizar P&L calculado em tempo real no card
        try {
            const entryPriceElement = card.querySelector('strong');
            if (!entryPriceElement) return;
            
            // Encontrar pre√ßo de entrada
            let entryPrice = null;
            const strongElements = card.querySelectorAll('strong');
            
            strongElements.forEach(element => {
                if (element.parentElement && 
                    element.parentElement.textContent.includes('Pre√ßo de Entrada')) {
                    entryPrice = parseFloat(element.textContent.replace(/[$,]/g, ''));
                }
            });
            
            if (!entryPrice) return;
            
            // Calcular P&L atualizado
            const pnlPercent = ((currentPrice - entryPrice) / entryPrice * 100);
            const pnlValue = currentPrice - entryPrice;
            const isProfit = pnlValue >= 0;
            
            // Encontrar e atualizar elemento de P&L
            const pnlContainer = card.querySelector('.bg-success, .bg-danger');
            if (pnlContainer) {
                // Atualizar classes baseado no resultado
                pnlContainer.classList.remove('bg-success', 'bg-danger', 'bg-opacity-10');
                pnlContainer.classList.add(isProfit ? 'bg-success' : 'bg-danger', 'bg-opacity-10');
                
                // Atualizar texto do P&L
                const pnlTextElement = pnlContainer.querySelector('.fw-bold');
                if (pnlTextElement) {
                    pnlTextElement.textContent = `${isProfit ? '+' : ''}$${this.formatPrice(Math.abs(pnlValue), symbol)} (${isProfit ? '+' : ''}${pnlPercent.toFixed(2)}%)`;
                    pnlTextElement.classList.remove('text-success', 'text-danger');
                    pnlTextElement.classList.add(isProfit ? 'text-success' : 'text-danger');
                }
            }
            
        } catch (error) {
            console.warn('Erro ao atualizar P&L do card:', error);
        }
    }

    updateActiveTradesPricesVisual(newPrice) {
        // Atualizar pre√ßos em cards de trades ativos com anima√ß√µes visuais
        const activeTradesContainer = document.getElementById('activeTradesList');
        if (!activeTradesContainer) return;
        
        const tradeCards = activeTradesContainer.querySelectorAll('.trade-card');
        
        tradeCards.forEach(card => {
            // Encontrar elementos de pre√ßo atual no card
            const currentPriceElements = card.querySelectorAll('.text-success, .text-danger');
            const pnlElements = card.querySelectorAll('[class*="text-success"], [class*="text-danger"]');
            
            // Verificar se o card pertence ao ativo atual
            const symbolElement = card.querySelector('.text-primary');
            if (symbolElement && symbolElement.textContent.trim() === this.currentSymbol) {
                // Animar indica√ß√µes de P&L baseadas na mudan√ßa de pre√ßo
                const lastPrice = this.lastPrices[this.currentSymbol] || newPrice;
                const isUpward = newPrice > lastPrice;
                
                // Adicionar efeito visual baseado na dire√ß√£o do pre√ßo
                if (isUpward) {
                    card.classList.add('profit-indicator');
                    card.classList.remove('loss-indicator');
                    
                    // Efeito de brilho verde
                    card.style.animation = 'profitGlow 1s ease-in-out';
                } else if (newPrice < lastPrice) {
                    card.classList.add('loss-indicator');
                    card.classList.remove('profit-indicator');
                    
                    // Efeito de brilho vermelho
                    card.style.animation = 'lossGlow 1s ease-in-out';
                }
                
                // Remover anima√ß√£o ap√≥s completar
                setTimeout(() => {
                    card.style.animation = '';
                }, 1000);
                
                // Animar elementos de pre√ßo espec√≠ficos
                pnlElements.forEach(element => {
                    if (element.textContent.includes('$') || element.textContent.includes('%')) {
                        element.style.animation = isUpward ? 'priceFlash 0.5s ease-in-out' : 'priceFlashRed 0.5s ease-in-out';
                        
                        setTimeout(() => {
                            element.style.animation = '';
                        }, 500);
                    }
                });
            }
        });
    }

    showAlert(message, type = 'info') {
        // Criar elemento de alerta com melhor styling
        const alert = document.createElement('div');
        alert.className = `alert alert-${type} alert-dismissible fade show position-fixed shadow-lg`;
        alert.style.cssText = 'top: 100px; right: 20px; z-index: 1050; min-width: 350px; border-radius: 10px;';
        alert.innerHTML = `
            <div class="d-flex align-items-center">
                <i class="fas ${this.getAlertIcon(type)} me-2"></i>
                <div>${message}</div>
                <button type="button" class="btn-close ms-auto" data-bs-dismiss="alert"></button>
            </div>
        `;
        
        document.body.appendChild(alert);
        
        // Remover automaticamente ap√≥s 5 segundos
        setTimeout(() => {
            if (alert.parentNode) {
                alert.parentNode.removeChild(alert);
            }
        }, 5000);
    }

    showSpecificErrorAlert(errorMessage, errorType) {
        let alertType = 'danger';
        let icon = '‚ùå';
        let title = 'Erro';
        
        switch(errorType) {
            case 'cooldown':
                alertType = 'warning';
                icon = '‚è∞';
                title = 'Aguarde';
                break;
            case 'no_data':
            case 'insufficient_data':
            case 'invalid_data':
                alertType = 'info';
                icon = 'üìä';
                title = 'Dados Indispon√≠veis';
                break;
            case 'low_confluence':
                alertType = 'secondary';
                icon = 'üìà';
                title = 'Condi√ß√µes de Mercado';
                break;
            case 'price_error':
                alertType = 'warning';
                icon = 'üí∞';
                title = 'Erro de Pre√ßo';
                break;
            case 'indicators_error':
            case 'technical_error':
            case 'system_error':
                alertType = 'danger';
                icon = '‚ö†Ô∏è';
                title = 'Erro T√©cnico';
                break;
            default:
                alertType = 'danger';
                icon = '‚ùå';
                title = 'Erro';
        }
        
        const message = `<strong>${icon} ${title}:</strong> ${errorMessage}`;
        this.showAlert(message, alertType);
    }

    getAlertIcon(type) {
        const icons = {
            'success': 'fa-check-circle',
            'danger': 'fa-exclamation-triangle',
            'warning': 'fa-exclamation-circle',
            'info': 'fa-info-circle'
        };
        return icons[type] || 'fa-info-circle';
    }    async updateCurrentPrice() {
        try {
            // Usar API da Binance diretamente para dados de mercado completos
            const marketData = await this.getBinanceMarketData(this.currentSymbol);
            
            if (marketData) {
                this.updateMarketDisplay(marketData);
                console.log(`üí∞ Dados de mercado atualizados: ${this.currentSymbol}`);
            } else {
                // Fallback para endpoints locais
                let response = await fetch(`/api/price/realtime/${this.currentSymbol}`);
                let data = await response.json();
                
                if (!data.success) {
                    response = await fetch(`/api/price/${this.currentSymbol}`);
                    data = await response.json();
                }
                
                if (data.success) {
                    this.displayCurrentPrice(data.price);
                    console.log(`üí∞ Pre√ßo ${data.source || 'local'}: ${this.currentSymbol} = $${this.formatPrice(data.price, this.currentSymbol)}`);
                }
            }
        } catch (error) {
            console.error('‚ùå Erro ao atualizar pre√ßo:', error);
        }
    }

    async getBinanceMarketData(symbol) {
        try {
            // Converter s√≠mbolo para formato Binance se necess√°rio
            const binanceSymbol = symbol.replace('/', '');
            
            // Buscar dados de ticker 24h da Binance
            const response = await fetch(`https://api.binance.com/api/v3/ticker/24hr?symbol=${binanceSymbol}`);
            
            if (!response.ok) {
                console.warn(`‚ö†Ô∏è Erro na API Binance para ${symbol}: ${response.status}`);
                return null;
            }
            
            const data = await response.json();
            
            return {
                symbol: symbol,
                price: parseFloat(data.lastPrice),
                change24h: parseFloat(data.priceChange),
                changePercent24h: parseFloat(data.priceChangePercent),
                high24h: parseFloat(data.highPrice),
                low24h: parseFloat(data.lowPrice),
                volume24h: parseFloat(data.volume),
                timestamp: Date.now()
            };
        } catch (error) {
            console.error(`‚ùå Erro ao buscar dados Binance para ${symbol}:`, error);
            return null;
        }
    }    updateMarketDisplay(marketData) {
        console.log('üìä Atualizando display de mercado:', marketData);
        
        const lastPrice = this.lastPrices[marketData.symbol] || marketData.price;
        const priceChanged = lastPrice !== marketData.price;
        const isUpward = marketData.price > lastPrice;
        
        // Atualizar pre√ßo principal
        this.updatePriceElement('navCurrentPrice', marketData.price, priceChanged, isUpward, marketData.symbol);
        
        // Atualizar varia√ß√£o 24h
        this.updateChangeDisplay(marketData.changePercent24h);
        
        // Atualizar outros dados de mercado no header
        this.updateMarketStats(marketData);
        
        // Salvar √∫ltimo pre√ßo
        this.lastPrices[marketData.symbol] = marketData.price;
        
        console.log(`üí∞ Display atualizado - ${marketData.symbol}: $${this.formatPrice(marketData.price, marketData.symbol)} (${marketData.changePercent24h >= 0 ? '+' : ''}${marketData.changePercent24h.toFixed(2)}%)`);
    }

    updatePriceElement(elementId, price, priceChanged, isUpward, symbol) {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        const formattedPrice = `$${this.formatPrice(price, symbol)}`;
        element.textContent = formattedPrice;
        
        if (priceChanged) {
            // Remover classes anteriores
            element.classList.remove('price-up', 'price-down');
            
            // Adicionar nova classe com anima√ß√£o
            const changeClass = isUpward ? 'price-up' : 'price-down';
            element.classList.add(changeClass);
            
            // Anima√ß√£o de pulso
            element.style.transform = 'scale(1.05)';
            setTimeout(() => {
                element.style.transform = 'scale(1)';
                element.classList.remove(changeClass);
            }, 500);
        }
    }

    updateChangeDisplay(changePercent) {
        // Criar ou atualizar elemento de varia√ß√£o se n√£o existir
        let changeElement = document.getElementById('priceChange24h');
        if (!changeElement) {
            const navPrice = document.getElementById('navCurrentPrice');
            if (navPrice) {
                changeElement = document.createElement('span');
                changeElement.id = 'priceChange24h';
                changeElement.className = 'ms-2 fw-bold';
                navPrice.parentNode.appendChild(changeElement);
            }
        }
        
        if (changeElement) {
            const isPositive = changePercent >= 0;
            const sign = isPositive ? '+' : '';
            const colorClass = isPositive ? 'text-success' : 'text-danger';
            const icon = isPositive ? '‚ñ≤' : '‚ñº';
            
            changeElement.textContent = `${icon} ${sign}${changePercent.toFixed(2)}%`;
            changeElement.className = `ms-2 fw-bold ${colorClass}`;
        }
    }

    updateMarketStats(marketData) {
        // Atualizar high/low se existirem elementos
        this.updateStatElement('high24h', marketData.high24h, marketData.symbol);
        this.updateStatElement('low24h', marketData.low24h, marketData.symbol);
        this.updateStatElement('volume24h', this.formatVolume(marketData.volume24h));
    }

    updateStatElement(elementId, value, symbol = null) {
        const element = document.getElementById(elementId);
        if (element) {
            if (symbol && typeof value === 'number') {
                element.textContent = `$${this.formatPrice(value, symbol)}`;
            } else {
                element.textContent = value;
            }
        }
    }    formatVolume(volume) {
        if (volume >= 1e9) {
            return (volume / 1e9).toFixed(2) + 'B';
        } else if (volume >= 1e6) {
            return (volume / 1e6).toFixed(2) + 'M';
        } else if (volume >= 1e3) {
            return (volume / 1e3).toFixed(2) + 'K';
        }
        return volume.toFixed(2);
    }

    updateInterfaceElements() {
        // Atualizar elementos da interface com o ativo atual
        const elements = [
            { id: 'currentSymbol', value: this.currentSymbol },
            { id: 'navCurrentAsset', value: this.currentSymbol },
            { id: 'selectedAssetBadge', value: this.currentSymbol }
        ];

        elements.forEach(({ id, value }) => {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = value;
            }
        });

        // Atualizar t√≠tulo do card do gr√°fico se existir
        const chartTitle = document.querySelector('.card-header h5');
        if (chartTitle) {
            chartTitle.innerHTML = `<i class="fas fa-chart-candlestick me-2"></i>An√°lise T√©cnica - ${this.currentSymbol}`;
        }        console.log(`üîÑ Interface atualizada para ativo: ${this.currentSymbol}`);
    }

    updateActiveTradesCounter(count) {
        const counterElement = document.getElementById('activeTradesCount');
        if (counterElement) {
            counterElement.textContent = count;
            
            // Adicionar anima√ß√£o ao contador quando mudar
            if (count > 0) {
                counterElement.classList.remove('bg-primary');
                counterElement.classList.add('bg-success');
            } else {
                counterElement.classList.remove('bg-success');
                counterElement.classList.add('bg-primary');
            }
        }
    }

    displayCurrentPrice(price) {
        const lastPrice = this.lastPrices[this.currentSymbol] || price;
        const priceChanged = lastPrice !== price;
        const isUpward = price > lastPrice;
        const formattedPrice = `$${this.formatPrice(price, this.currentSymbol)}`;
        
        // Atualizar o indicador de pre√ßo na navbar com anima√ß√µes
        const navPriceElement = document.getElementById('currentPrice');
        if (navPriceElement) {
            navPriceElement.textContent = formattedPrice;
            
            if (priceChanged) {
                // Remover classes anteriores
                navPriceElement.classList.remove('price-up', 'price-down', 'priceFlash', 'priceFlashRed');
                
                // Adicionar anima√ß√£o baseada na dire√ß√£o
                if (isUpward) {
                    navPriceElement.classList.add('price-up', 'priceFlash');
                } else {
                    navPriceElement.classList.add('price-down', 'priceFlashRed');
                }
                
                // Remover classes ap√≥s anima√ß√£o
                setTimeout(() => {
                    navPriceElement.classList.remove('price-up', 'price-down', 'priceFlash', 'priceFlashRed');
                }, 600);
            }
        }
        
        // Atualizar o pre√ßo no painel lateral (card gerador de sinais)
        const sidebarPriceElement = document.getElementById('sidebarCurrentPrice');
        if (sidebarPriceElement) {
            sidebarPriceElement.textContent = `$${this.formatPrice(price, this.currentSymbol)}`;
            
            // Anima√ß√£o visual quando o pre√ßo muda
            if (priceChanged) {
                // Remover classes anteriores
                sidebarPriceElement.classList.remove('price-up', 'price-down');
                
                // Adicionar nova classe de anima√ß√£o
                if (isUpward) {
                    sidebarPriceElement.classList.add('price-up');
                } else {
                    sidebarPriceElement.classList.add('price-down');
                }
                
                // Anima√ß√£o CSS personalizada
                sidebarPriceElement.style.animation = isUpward ? 'priceFlash 0.6s ease-in-out' : 'priceFlashRed 0.6s ease-in-out';
                
                setTimeout(() => {
                    sidebarPriceElement.classList.remove('price-up', 'price-down');
                    sidebarPriceElement.style.animation = '';
                }, 600);
            }
            
            // Calcular varia√ß√£o de pre√ßo
            const priceChangePercent = ((price - lastPrice) / lastPrice * 100);
            const priceChangeElement = document.getElementById('priceChange');
            
            if (priceChangeElement && priceChanged) {
                const changeText = `${priceChangePercent >= 0 ? '+' : ''}${priceChangePercent.toFixed(2)}%`;
                priceChangeElement.textContent = changeText;
                priceChangeElement.className = `badge ms-2 ${priceChangePercent >= 0 ? 'bg-success' : 'bg-danger'}`;
                
                // Anima√ß√£o no badge de mudan√ßa
                priceChangeElement.style.animation = 'pulse 0.5s ease-in-out';
                setTimeout(() => {
                    priceChangeElement.style.animation = '';
                }, 500);
            }
        }
        
        // Atualizar outros elementos de pre√ßo na interface com anima√ß√µes
        const symbolPriceElements = document.querySelectorAll('.current-price');
        symbolPriceElements.forEach(element => {
            element.textContent = formattedPrice;
            
            if (priceChanged) {
                element.classList.remove('price-up', 'price-down');
                
                if (isUpward) {
                    element.classList.add('price-up');
                } else {
                    element.classList.add('price-down');
                }
                
                setTimeout(() => {
                    element.classList.remove('price-up', 'price-down');
                }, 600);
            }
        });
        
        // Atualizar pre√ßos em trades ativos com indica√ß√µes visuais
        this.updateActiveTradesPricesVisual(price);
        
        // Chamar m√©todo de melhoramento de exibi√ß√£o de pre√ßos
        this.enhancePriceDisplay();
        
        // Armazenar pre√ßo anterior
        this.lastPrices[this.currentSymbol] = price;
        
        console.log(`üí∞ Pre√ßo atualizado: ${this.currentSymbol} = ${formattedPrice} ${priceChanged ? (isUpward ? 'üìà' : 'üìâ') : ''}`);
    }

    // Mapeamento de s√≠mbolos para TradingView
    getSymbolMapping() {
        return {
            // Crypto Major
            'BTCUSDT': 'BINANCE:BTCUSDT',
            'ETHUSDT': 'BINANCE:ETHUSDT',
            'ADAUSDT': 'BINANCE:ADAUSDT',
            'BNBUSDT': 'BINANCE:BNBUSDT',
            'SOLUSDT': 'BINANCE:SOLUSDT',
            'XRPUSDT': 'BINANCE:XRPUSDT',
            'DOTUSDT': 'BINANCE:DOTUSDT',
            'LINKUSDT': 'BINANCE:LINKUSDT',
            
            // Crypto Alt
            'MATICUSDT': 'BINANCE:MATICUSDT',
            'AVAXUSDT': 'BINANCE:AVAXUSDT',
            'LTCUSDT': 'BINANCE:LTCUSDT',            'UNIUSDT': 'BINANCE:UNIUSDT',
            'ATOMUSDT': 'BINANCE:ATOMUSDT',
            'ALGOUSDT': 'BINANCE:ALGOUSDT'
            
            // Forex e √çndices removidos - sistema agora suporta apenas crypto
        };
    }    changeAsset(newSymbol) {
        console.log(`üîÑ Mudando ativo para: ${newSymbol}`);
        
        // Validar se o s√≠mbolo √© diferente do atual
        if (this.currentSymbol === newSymbol) {
            console.log('‚ö†Ô∏è Ativo j√° selecionado, ignorando mudan√ßa');
            return;
        }
        
        // Mostrar loading no gr√°fico
        const chartContainer = document.getElementById('tradingview_chart');
        if (chartContainer) {
            chartContainer.innerHTML = `
                <div class="d-flex justify-content-center align-items-center h-100">
                    <div class="text-center">
                        <div class="spinner-border text-primary mb-3" role="status">
                            <span class="visually-hidden">Carregando...</span>
                        </div>
                        <p class="text-muted">Carregando gr√°fico de ${newSymbol}...</p>
                    </div>
                </div>
            `;
        }
        
        this.currentSymbol = newSymbol;
        
        // Atualizar interface com anima√ß√£o
        const updateElement = (id, value) => {
            const element = document.getElementById(id);
            if (element) {
                element.style.transition = 'all 0.3s ease';
                element.style.transform = 'scale(1.05)';
                element.textContent = value;
                setTimeout(() => {
                    element.style.transform = 'scale(1)';
                }, 300);
            }
        };
        
        updateElement('currentSymbol', newSymbol);
        updateElement('navCurrentAsset', newSymbol);
        updateElement('selectedAssetBadge', newSymbol);
        
        // Atualizar t√≠tulo do card do gr√°fico
        const chartTitle = document.querySelector('.card-header h5');
        if (chartTitle) {
            chartTitle.innerHTML = `<i class="fas fa-chart-candlestick me-2"></i>An√°lise T√©cnica - ${newSymbol}`;
        }
          // Atualizar gr√°fico TradingView
        this.updateTradingViewChart(newSymbol);
        
        // Atualizar dados de mercado imediatamente
        this.updateCurrentPrice();
        
        // Limpar sinal atual se existir
        this.clearCurrentSignal();
        
        // Reiniciar atualiza√ß√£o de pre√ßos para o novo ativo
        this.stopPriceUpdates();
        setTimeout(() => {
            this.startPriceUpdates();
        }, 1000);
        
        // Recarregar dados do portfolio para o novo ativo
        this.loadPortfolio();
        this.loadActiveTradesStatus();
        
        // Mostrar notifica√ß√£o com √≠cone do ativo
        this.showNotification(`üìà Ativo alterado para ${newSymbol}`, 'success');
        
        // Log para debugging
        console.log(`‚úÖ Ativo alterado com sucesso para: ${newSymbol}`);
    }

    changeTimeframe(newTimeframe) {
        console.log(`‚è∞ Mudando timeframe para: ${newTimeframe}`);
        
        this.currentTimeframe = newTimeframe;
        
        // Atualizar gr√°fico TradingView com novo timeframe
        this.updateTradingViewChart(this.currentSymbol);
        
        this.showAlert(`Timeframe alterado para ${newTimeframe}`, 'info');
    }

    convertTimeframeForTradingView(timeframe) {
        // Converter timeframes para formato TradingView
        const timeframeMapping = {
            '1m': '1',
            '5m': '5',
            '15m': '15',
            '30m': '30',
            '1h': '60',
            '4h': '240',
            '1d': 'D',
            '1w': 'W'
        };
        return timeframeMapping[timeframe] || '5';
    }    updateTradingViewChart(symbol) {
        const symbolMapping = this.getSymbolMapping();
        const tradingViewSymbol = symbolMapping[symbol] || `BINANCE:${symbol}`;
        const tradingViewTimeframe = this.convertTimeframeForTradingView(this.currentTimeframe);
        
        console.log(`üìà Atualizando gr√°fico: ${symbol} -> ${tradingViewSymbol}, timeframe: ${this.currentTimeframe} -> ${tradingViewTimeframe}`);
        
        // Remover widget existente com transi√ß√£o suave
        if (this.tradingViewWidget) {
            const container = document.getElementById('tradingview_chart');
            if (container) {
                container.style.opacity = '0.5';
                container.style.transition = 'opacity 0.3s ease';
                
                setTimeout(() => {
                    container.innerHTML = '';
                    this.createTradingViewWidget(tradingViewSymbol, tradingViewTimeframe, container);
                }, 300);
            }
        } else {
            const container = document.getElementById('tradingview_chart');
            this.createTradingViewWidget(tradingViewSymbol, tradingViewTimeframe, container);
        }
    }
    
    createTradingViewWidget(tradingViewSymbol, tradingViewTimeframe, container) {
        // Criar novo widget
        this.tradingViewWidget = new TradingView.widget({
            "width": "100%",
            "height": "600",
            "symbol": tradingViewSymbol,
            "interval": tradingViewTimeframe,
            "timezone": "America/Sao_Paulo",
            "theme": "light",
            "style": "1",
            "locale": "pt_BR",
            "toolbar_bg": "#f1f3f6",
            "enable_publishing": false,
            "allow_symbol_change": false,
            "container_id": "tradingview_chart",
            "studies": [
                "RSI@tv-basicstudies",
                "MACD@tv-basicstudies",
                "MASimple@tv-basicstudies"
            ],
            "onChartReady": () => {
                console.log(`üìà TradingView carregado para ${tradingViewSymbol} - configurando captura de pre√ßos`);
                this.setupTradingViewPriceCapture();
                
                // Restaurar opacidade do container
                if (container) {
                    container.style.opacity = '1';
                    container.style.transition = 'opacity 0.5s ease';
                }
                
                // Notificar que o gr√°fico foi carregado
                this.showNotification(`üìä Gr√°fico carregado para ${tradingViewSymbol.replace('BINANCE:', '')}`, 'info');
            }
        });
        
        console.log(`‚úÖ Widget TradingView criado para: ${tradingViewSymbol}`);
    }

    setupTradingViewPriceCapture() {
        try {
            // Aguardar o widget estar completamente carregado
            setTimeout(() => {
                // Configurar listener para mensagens do TradingView
                this.setupTradingViewMessageListener();
                
                // Configurar intervalo para tentar capturar pre√ßo do DOM
                this.setupDOMPriceCapture();
                
                console.log('‚úÖ Captura de pre√ßos do TradingView configurada');
            }, 3000);
        } catch (error) {
            console.error('‚ùå Erro ao configurar captura de pre√ßos:', error);
            // Fallback para o m√©todo anterior
            this.updateCurrentPrice();
        }
    }
    
    setupTradingViewMessageListener() {
        // Escutar mensagens do iframe do TradingView
        window.addEventListener('message', (event) => {
            try {
                if (event.origin.includes('tradingview.com') && event.data) {
                    const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
                    
                    // Procurar por dados de pre√ßo nas mensagens
                    if (data.name === 'quote-update' || data.name === 'quote_update') {
                        if (data.data && data.data.lp) {
                            const price = parseFloat(data.data.lp);
                            if (!isNaN(price)) {
                                this.updatePriceDisplay(price);
                            }
                        }
                    }
                }
            } catch (e) {
                // Ignorar erros de parsing silenciosamente
            }
        });
    }
    
    setupDOMPriceCapture() {
        // Configurar intervalo para capturar pre√ßo do DOM do TradingView
        this.chartPriceInterval = setInterval(() => {
            this.capturePriceFromDOM();
        }, 1000); // Verificar a cada 1 segundo
    }
    
    capturePriceFromDOM() {
        try {
            // Tentar encontrar elementos de pre√ßo no iframe do TradingView
            const chartContainer = document.getElementById('tradingview_chart');
            if (chartContainer) {
                const iframe = chartContainer.querySelector('iframe');
                if (iframe && iframe.contentDocument) {
                    // Procurar por elementos que contenham o pre√ßo
                    const priceSelectors = [
                        '[data-name="legend-source-item"]',
                        '.js-symbol-last',
                        '[class*="price"]',
                        '[class*="last"]'
                    ];
                    
                    for (const selector of priceSelectors) {
                        const elements = iframe.contentDocument.querySelectorAll(selector);
                        for (const element of elements) {
                            const text = element.textContent || element.innerText;
                            const priceMatch = text.match(/([0-9,]+\.?[0-9]*)/g);
                            if (priceMatch) {
                                const price = parseFloat(priceMatch[0].replace(/,/g, ''));
                                if (!isNaN(price) && price > 1000) { // Filtro b√°sico para BTC
                                    this.updatePriceDisplay(price);
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        } catch (error) {
            // Fallback silencioso - iframe pode estar bloqueado por CORS
            // Usar API externa como backup
            if (Math.random() < 0.1) { // 10% das vezes para n√£o sobrecarregar
                this.updateCurrentPrice();
            }
        }
    }



    updatePriceDisplay(price) {
        if (price && !isNaN(price)) {
            // Atualizar elementos de pre√ßo diretamente
            const priceElements = {
                navPriceElement: document.getElementById('navPriceElement'),
                sidebarCurrentPrice: document.getElementById('sidebarCurrentPrice'),
                currentPriceElements: document.querySelectorAll('.current-price')
            };
            
            const formattedPrice = `$${this.formatPrice(price, this.currentSymbol)}`;
            
            // Atualizar pre√ßo na navega√ß√£o
            if (priceElements.navPriceElement) {
                const oldPrice = parseFloat(priceElements.navPriceElement.textContent.replace(/[$,]/g, ''));
                priceElements.navPriceElement.textContent = formattedPrice;
                
                // Anima√ß√£o visual
                if (!isNaN(oldPrice) && oldPrice !== price) {
                    priceElements.navPriceElement.style.transform = 'scale(1.05)';
                    priceElements.navPriceElement.style.color = price > oldPrice ? '#28a745' : '#dc3545';
                    setTimeout(() => {
                        priceElements.navPriceElement.style.transform = 'scale(1)';
                        priceElements.navPriceElement.style.color = '';
                    }, 300);
                }
            }
            
            // Atualizar pre√ßo no sidebar
            if (priceElements.sidebarCurrentPrice) {
                const oldPrice = parseFloat(priceElements.sidebarCurrentPrice.textContent.replace(/[$,]/g, ''));
                priceElements.sidebarCurrentPrice.textContent = formattedPrice;
                
                // Anima√ß√£o visual
                if (!isNaN(oldPrice) && oldPrice !== price) {
                    priceElements.sidebarCurrentPrice.style.transform = 'scale(1.05)';
                    priceElements.sidebarCurrentPrice.style.color = price > oldPrice ? '#28a745' : '#dc3545';
                    setTimeout(() => {
                        priceElements.sidebarCurrentPrice.style.transform = 'scale(1)';
                        priceElements.sidebarCurrentPrice.style.color = '';
                    }, 300);
                }
            }
            
            // Atualizar outros elementos com classe current-price
            priceElements.currentPriceElements.forEach(element => {
                element.textContent = formattedPrice;
            });
            
            console.log(`üí∞ Pre√ßo atualizado do gr√°fico: ${formattedPrice}`);
        }
    }

    clearCurrentSignal() {
        this.currentSignal = null;
        document.getElementById('signalContent').style.display = 'none';
        document.getElementById('signalActions').style.display = 'none';
        document.getElementById('generateSignalBtn').style.display = 'block';
    }    enhancePriceDisplay() {
        // Melhorar exibi√ß√£o de pre√ßos com anima√ß√µes
        const priceElements = document.querySelectorAll('[id*="price"], [id*="Price"]');
        
        priceElements.forEach(element => {
            if (element.dataset.lastPrice) {
                const currentPrice = parseFloat(element.textContent.replace(/[^0-9.-]/g, ''));
                const lastPrice = parseFloat(element.dataset.lastPrice);
                
                if (currentPrice > lastPrice) {
                    element.classList.add('price-up');
                    setTimeout(() => element.classList.remove('price-up'), 600);
                } else if (currentPrice < lastPrice) {
                    element.classList.add('price-down');
                    setTimeout(() => element.classList.remove('price-down'), 600);
                }
            }
            
            element.dataset.lastPrice = element.textContent.replace(/[^0-9.-]/g, '');
        });
    }

    addTradeCardAnimations() {
        // Adicionar anima√ß√µes aos cards de trades
        const tradeCards = document.querySelectorAll('.trade-card');
        
        tradeCards.forEach(card => {
            const pnlElement = card.querySelector('[class*="pnl"], [class*="profit"], [class*="loss"]');
            
            if (pnlElement) {
                const pnlValue = parseFloat(pnlElement.textContent.replace(/[^0-9.-]/g, ''));
                
                if (pnlValue > 0) {
                    card.classList.add('profit-indicator');
                } else if (pnlValue < 0) {
                    card.classList.add('loss-indicator');
                }
            }
        });
    }

    showNotification(message, type = 'info') {
        const container = document.getElementById('notificationContainer');
        if (!container) {
            console.warn('Container de notifica√ß√µes n√£o encontrado');
            return;
        }
        
        const id = 'notification-' + Date.now();
        
        const alertClass = {
            'success': 'alert-success',
            'error': 'alert-danger',
            'warning': 'alert-warning',
            'info': 'alert-info'
        }[type] || 'alert-info';

        const notification = document.createElement('div');
        notification.id = id;
        notification.className = `alert ${alertClass} alert-dismissible fade show notification`;
        notification.innerHTML = `
            ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;

        container.appendChild(notification);

        // Auto remove after 5 seconds
        setTimeout(() => {
            const element = document.getElementById(id);
            if (element) {
                element.remove();
            }
        }, 5000);
    }

    // Expandir dados ap√≥s startup (executar ap√≥s 30 segundos)
    expandDataAfterStartup() {
        setTimeout(() => {
            console.log('üöÄ Expandindo cobertura de dados...');
            fetch('/api/expand_data', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log('‚úÖ Expans√£o de dados iniciada em background');
                        this.showNotification('Expandindo dados de mercado em background...', 'info');
                    }
                })
                .catch(error => {
                    console.warn('‚ö†Ô∏è Erro ao expandir dados:', error);
                });
        }, 30000); // 30 segundos ap√≥s carregamento
    }

    // Carregar dados de s√≠mbolo sob demanda
    loadSymbolDataOnDemand(symbol, timeframe = '1h') {
        return fetch('/api/load_symbol_data', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ symbol, timeframe })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log(`üìä Dados carregados: ${symbol} ${timeframe}`);
            }
            return data;
        })
        .catch(error => {
            console.warn(`‚ö†Ô∏è Erro ao carregar ${symbol}:`, error);
            return { success: false };
        });
    }
}

// Fun√ß√£o global para fechar trades (chamada pelo onclick nos bot√µes)
window.closeTrade = function(tradeId) {
    if (window.dashboard) {
        window.dashboard.closeTrade(tradeId);
    }
};

// Inicializar dashboard quando a p√°gina carregar
document.addEventListener('DOMContentLoaded', function() {
    console.log('üéØ DOM carregado, inicializando dashboard...');
    window.dashboard = new SimpleTradingDashboard();
});

// Exportar para uso global
window.SimpleTradingDashboard = SimpleTradingDashboard;